# This Python script, SConscript, invoked by the SConscript in the upper directory,
#
# 1. builds utils static library

import os
import subprocess
from subprocess import Popen, PIPE
import shutil
import getpass

Import("env")


def is_git_available():
    """Checks if the 'git' command is available in the system's PATH."""
    try:
        # Use subprocess.DEVNULL to silence output
        subprocess.run(['git', '--version'], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError, OSError):
        # CalledProcessError is raised if the command returns a non-zero exit code
        # (e.g., if git is installed but misconfigured)
        # FileNotFoundError/OSError is raised if the git executable is not found
        return False


if os.sys.platform == 'win32':
    ppf = '/D' # Visual Studio preprocessor define flag
    edq = '\\"' # Need to escape double quote on Windows
    esq = ''
    username = getpass.getuser()
else:
    ppf = '-D' # GCC preprocessor define flag
    edq = '"'
    esq = '\'' # Linux uses an extra single quote
    username = os.environ['USER']

root = Dir('#').abspath
version_info_path = os.path.join(root,"utils/version_info.h")
version_tmpl_path = os.path.join(root,"utils/version_info.tmpl")
if os.path.exists(version_info_path):
    os.remove(version_info_path)
shutil.copy(version_tmpl_path, version_info_path )

# Extract major and minor versions from version info file
with open(version_info_path) as fid01:
    def_lines = [lval.strip().split() for lval in fid01.readlines() if lval.startswith('#define')]

for lval in def_lines:
    if (lval[1] == 'MAJOR_VERSION'):
        ver_maj = lval[2]
    if (lval[1] == 'MINOR_VERSION'):
        ver_min = lval[2]

ver_tag = "v{:s}.{:s}".format(ver_maj, ver_min)


rev = '0'
branch = "unknownbranch"
sha1 = "_unknownsha1"
git_date = "unknown_date_time"


if is_git_available():
    # commit/branch info
    git_rev_handle = Popen(["git","rev-list","{:s}..HEAD".format(ver_tag),"--count"], stdout=PIPE, stderr=PIPE)
    tmp_rev = git_rev_handle.stdout.read().decode().strip().strip( '"\'' ).replace(" ","_")
    git_err = git_rev_handle.stderr.read().decode()
    if not git_err:
        # Raising an error breaks the Jenkins build; should be an error once off of Jenkins
        # raise Exception(git_err)
        rev = tmp_rev

    git_branch_handle = Popen( "git rev-parse --abbrev-ref HEAD".split(), stdout=PIPE )
    tmp_branch = git_branch_handle.stdout.read().decode().strip().strip( '"\'' ).replace(" ","_")
    if tmp_branch != "":
        branch = tmp_branch

    git_sha_handle = Popen( "git log --pretty=format:'%h' -n 1".split(), stdout=PIPE )
    tmp_sha1 = git_sha_handle.stdout.read().decode().strip().strip( '"\'' ).replace(" ","_")
    if tmp_sha1 != "":
        sha1 = tmp_sha1
    sha1 = '(' + sha1 + ')'

    git_date_handle = Popen( "git log -1 --pretty=%ai".split(), stdout=PIPE )
    tmp_git_date = git_date_handle.stdout.read().decode().strip().strip( '"\'' ).replace(' ','_')
    if tmp_git_date != "":
        git_date = tmp_git_date

print( branch + sha1 )

REV_STR = ppf + 'REVISION_NUMBER=' + esq + rev + esq
env.Append( CCFLAGS=[ REV_STR ] )

BRH_STR = ppf + 'SCCS_BRANCH='+ esq + edq + branch + sha1 + edq + esq
env.Append( CCFLAGS=[ BRH_STR ] )

GIT_STR = ppf + 'SCCS_DATE=' + esq + edq + git_date + edq + esq
env.Append( CCFLAGS=[ GIT_STR ] )

USR_STR = ppf + 'BUILDER_NAME='+ esq + edq + username + edq + esq
env.Append( CCFLAGS=[ USR_STR ] )


utilsSrcFiles = [
    "BaseProperties.cpp",
    "BinaryArchiveReader.cpp",
    "BinaryArchiveWriter.cpp",
    "ConfigParams.cpp",
    "Configuration.cpp",
    "Configure.cpp",
    "Coredump.cpp",
    "DistributionBase.cpp",
    "DistributionsConfigurable.cpp",
    "DistributionFactory.cpp",
    "Distributions.cpp",
    "Environment.cpp",
    "EventTrigger.cpp",
    "EventTriggerNode.cpp",
    "EventTriggerCoordinator.cpp",
    "Exceptions.cpp",
    "FileSystem.cpp",
    "IArchive.cpp",
    "IdmDateTime.cpp",
    "IdmMpi.cpp",
    "InterpolatedValueMap.cpp",
    "InstructionSetInfo.cpp",
    "ISerializable.cpp",
    "ISupports.cpp",
    "JsonFullReader.cpp",
    "JsonFullWriter.cpp",
    "JsonObject.cpp",
    "JsonObjectDemog.cpp",
    "JsonRawReader.cpp",
    "JsonRawWriter.cpp",
    "Log.cpp",
    "MathFunctions.cpp",
    "numpy-files.cpp",
    "Memory.cpp",
    "NodeProperties.cpp",
    "PiecewiseDistributionBase.cpp",
    "ProgramOptions.cpp",
    "ProgVersion.cpp",
    "Properties.cpp",
    "RANDOM.cpp",
    "RandomNumberGeneratorFactory.cpp",
    "RapidJsonImpl.cpp",
    "Serializer.cpp",
    "Sigmoid.cpp",
    "StatusReporter.cpp",
    "stdafx.cpp",
    "suids.cpp",
    "Types.cpp",
    "Timers.cpp",
]

utilsLib = env.StaticLibrary('utils', utilsSrcFiles)
